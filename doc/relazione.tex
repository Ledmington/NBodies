\documentclass[12pt,a4paper,oneside]{article}

\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{wrapfig}

\usepackage[
	linesnumbered,
	ruled,
	italiano
]{algorithm2e}

\usepackage{tikz}
\usetikzlibrary{arrows,shapes,automata,petri,positioning,calc}

\tikzset{
	place/.style={
		circle,
		thick,
		draw=black,
		fill=gray!50,
		minimum size=6mm,
	},
	state/.style={
		circle,
		thick,
		draw=blue!75,
		fill=blue!20,
		minimum size=6mm,
	},
}

% infinite loop pseudocode command
\SetKwFor{Loop}{Loop forever}{}{EndLoop}

\begin{document}
	
	\title{N-bodies simulation\\Assignment programmazione concorrente e distribuita}
	\author{Filippo Barbari}
	\date{}%no date
	\maketitle
	
	\tableofcontents
	\newpage
	
	\section{Analisi}
	\subsection{Descrizione della simulazione}
	Questa simulazione è una variante della nota "simulazione di $N$ corpi". La simulazione è composta da:
	\begin{itemize}
		\item un numero $N$ di corpi ciascuno dotato di massa ma incorporeo (non ha una dimensione)
		\item un dominio bidimensionale finito di forma rettangolare e allineato con gli assi cartesiani
		\item una forza repulsiva tra i corpi (descritta in dettaglio di seguito)
		\item una forza d'attrito applicata sui singoli corpi
	\end{itemize}
	
	\subsection{Analisi dell'algoritmo}
	\begin{algorithm}
		\SetAlgorithmName{Algoritmo}{}{}
		\KwIn{B, array dei corpi}
		\KwIn{bounds, i bordi della simulazione}
		\KwIn{steps, numero di iterazioni da calcolare}
		
		\For{$steps$ times}{
			\ForEach{Body $b$ in $B$}{
				computeTotalForces($b$)\;
			}
			\ForEach{Body $b$ in $B$}{
				computeAcceleration($b$)\;
				updateVelocity($b$)\;
				updatePosition($b$)\;
				checkAndSolveBoundaryCollisions($b$)\;
			}
		}
		\caption{N-Bodies simulation}
	\end{algorithm}
	
	\subsection{Analisi delle dipendenze tra dati}
	Questo algoritmo presenta due dipendenze molto importanti:
	\begin{itemize}
		\item il risultato di una determinata iterazione $i > 0$ dipende dal risultato dell'iterazione $i-1$
		\item il risultato dell'aggiornamento dei parametri di un qualsiasi corpo $b_i$ (accelerazione, velocità e posizione) dipende dal risultato del calcolo di tutte le forze repulsive agenti su $b_i$
	\end{itemize}
	
	\section{Design}
	\subsection{Mutua esclusione}
	Come emerso dall'analisi dell'algoritmo, non è necessario l'utilizzo di alcun meccanismo di mutua esclusione per evitare letture e scritture concorrenti sui dai dei singoli corpi. Difatti, è sufficiente \textbf{partizionare} l'array globale dei corpi in tante porzioni quanti sono i thread utilizzati, ognuno dei quali si occuperà di aggiornare solamente i corpi della propria partizione.
	
	\subsection{Sincronizzazione}
	Un problema più importante consiste, invece, nella \textbf{sincronizzazione} dei thread al fine di non violare nessuna delle due dipendenze tra dati individuate. Per fare ciò utilizziamo due Barrier, ovvero dei costrutti che permettono la sincronizzazione globale dei thread, come riportato nello pseudocodice di seguito. Le Barrier utilizzate sono implementate nella classe \texttt{nbodies.utils.barrier.ReusableBarrier}.
	
	\begin{algorithm}
		\SetAlgorithmName{Algoritmo}{}{}
		\KwIn{B, array dei corpi}
		\KwIn{bounds, i bordi della simulazione}
		\KwIn{steps, numero di iterazioni da calcolare}
		
		partition($B$)\;
		\For{$steps$ times}{
			\ForEach{Body $b$ in $B$}{
				computeTotalForces($b$)\;
			}
			barrier()\;
			\ForEach{Body $b$ in $B$}{
				computeAcceleration($b$)\;
				updateVelocity($b$)\;
				updatePosition($b$)\;
				checkAndSolveBoundaryCollisions($b$)\;
			}
			barrier()\;
		}
		\caption{Parallel N-Bodies simulation}
		\label{alg:sim-barrier}
	\end{algorithm}

	\subsection{GUI}
	Per evitare un eccessivo overhead della GUI, ho scelto di renderla completamente asincrona rispetto alla simulazione.
	
	\section{Dettagli implementativi}
	Per evitare \textit{overhead} non necessari e per semplificare il codice, ogni \texttt{Worker}, prima di cominciare il ciclo vero e proprio, estrae dalla lista dei corpi una lista di puntatori ai corpi su cui deve operare.
	
	\section{Valutazione}
	\subsection{Correttezza}
	\hfill
	\begin{minipage}{.55\textwidth}
		Per semplificare la modellazione dell'algoritmo e la valutazione della correttezza, lavoreremo su una versione semplificata dell'algoritmo \ref{alg:sim-barrier} qui riportata.
	\end{minipage}
	\hfill
	\begin{minipage}{.4\textwidth}
		\begin{algorithm}[H]
			\SetAlgorithmName{Algoritmo}{}{}
			\Loop{}{
				CF\\
				B1\\
				UP\\
				B2
			}
			\caption{Simplified N-Bodies simulation}
		\end{algorithm}
	\end{minipage}
	\hfill
	
	\subsubsection{Diagramma degli stati}
	\begin{tikzpicture}[node distance=1cm, >=stealth, auto, every place/.style={draw}]
		% nodes
		\node [place] (CFCF) {CF,CF};
		\coordinate[left of=CFCF] (left-CFCF);
		\coordinate[right of=CFCF] (right-CFCF);
		\node [place] (B1CF) [below =of left-CFCF] {B1,CF};
		\coordinate[left of=B1CF] (left-B1CF);
		\coordinate[right of=B1CF] (right-B1CF);
		\node [place] (CFB1) [below =of right-CFCF] {CF,B1};
		\coordinate[left of=CFB1] (left-CFB1);
		\coordinate[right of=CFB1] (right-CFB1);
		\node [place] (B1B1) [below =of left-CFB1] {B1,B1};
		\coordinate[left of=B1B1] (left-B1B1);
		\coordinate[right of=B1B1] (right-B1B1);
		
		\node [place] (UPB1) [below =of left-B1B1] {UP,B1};
		\coordinate[left of=UPB1] (left-UPB1);
		\coordinate[right of=UPB1] (right-UPB1);
		\node [place] (B1UP) [below =of right-B1B1] {B1,UP};
		\coordinate[left of=B1UP] (left-B1UP);
		\coordinate[right of=B1UP] (right-B1UP);
		\node [place] (B2B1) [below =of left-UPB1] {B2,B1};
		\coordinate[left of=B2B1] (left-B2B1);
		\coordinate[right of=B2B1] (right-B2B1);
		\node [place] (B1B2) [below =of right-B1UP] {B1,B2};
		\coordinate[left of=B1B2] (left-B1B2);
		\coordinate[right of=B1B2] (right-B1B2);
		\node [place] (UPUP) [below =of left-B1UP] {UP,UP};
		\coordinate[left of=UPUP] (left-UPUP);
		\coordinate[right of=UPUP] (right-UPUP);
		\node [place] (B2UP) [below =of left-UPUP] {B2,UP};
		\coordinate[left of=B2UP] (left-B2UP);
		\coordinate[right of=B2UP] (right-B2UP);
		\node [place] (UPB2) [below =of left-B1B2] {UP,B2};
		\coordinate[left of=UPB2] (left-UPB2);
		\coordinate[right of=UPB2] (right-UPB2);
		\node [place] (B2B2) [below =of left-UPB2] {B2,B2};
		\coordinate[left of=B2B2] (left-B2B2);
		\coordinate[right of=B2B2] (right-B2B2);
		
		% arcs
		\path[->] (CFCF) edge node {} (B1CF);
		\path[->] (CFCF) edge node {} (CFB1);
		\path[->] (B1CF) edge node {} (B1B1);
		\path[->] (CFB1) edge node {} (B1B1);
		
		\path[->] (B1B1) edge node {} (UPB1);
		\path[->] (B1B1) edge node {} (B1UP);
		\path[->] (UPB1) edge node {} (UPUP);
		\path[->] (UPB1) edge node {} (B2B1);
		\path[->] (B1UP) edge node {} (B1B2);
		\path[->] (B1UP) edge node {} (UPUP);
		\path[->] (B2B1) edge node {} (B2UP);
		\path[->] (UPUP) edge node {} (B2UP);
		\path[->] (UPUP) edge node {} (UPB2);
		\path[->] (B1B2) edge node {} (UPB2);
		\path[->] (B2UP) edge node {} (B2B2);
		\path[->] (UPB2) edge node {} (B2B2);
	\end{tikzpicture}
	
	\subsubsection{Rete di Petri}
	\begin{tikzpicture}[>=stealth, bend angle=90, auto]
		
		\tikzstyle{transition}=[rectangle,thick,draw=black!75,fill=black!20,minimum size=4mm]
		
		\node [place, tokens=1] (p1) {};
		\node [place] (p2) [node distance=1.5cm, below =of p1] {};
		\node [place] (p3) [node distance=1.5cm, below =of p2] {};
		\node [place] (p4) [node distance=1.5cm, below =of p3] {};
		
		\node [place, tokens=1] (q1) [node distance=3cm, right of=p1] {};
		\node [place] (q2) [node distance=1.5cm, below =of q1] {};
		\node [place] (q3) [node distance=1.5cm, below =of q2] {};
		\node [place] (q4) [node distance=1.5cm, below =of q3] {};
		
		\coordinate[node distance=1.5cm, right of=p2] (mid-p2);
		\coordinate[node distance=1.5cm, right of=p4] (mid-p4);
		
		\node [transition] (CF1) [node distance=0.5cm, below =of p1] {CF1} edge [pre] (p1) edge [post] (p2);
		\node [transition] (CF2) [node distance=0.5cm, below =of q1] {CF2} edge [pre] (q1) edge [post] (q2);
		\node [transition] (B1) [below =of mid-p2] {B1} edge [pre] (p2) edge [pre] (q2) edge [post] (p3) edge [post] (q3);
		\node [transition] (UP1) [node distance=0.5cm, below =of p3] {UP1} edge [pre] (p3) edge [post] (p4);
		\node [transition] (UP2) [node distance=0.5cm, below =of q3] {UP2} edge [pre] (q3) edge [post] (q4);
		\node [transition] (B2) [below =of mid-p4] {B2} edge [pre] (p4) edge [pre] (q4) edge [post, bend left] (p1) edge [post, bend right] (q1);
	\end{tikzpicture}
	
	\subsection{Prestazioni}
	\subsubsection{Tempi di esecuzione}
	I tempi riportati di seguito fanno riferimento ad un'esecuzione parallela che utilizza 8 thread.
	
	\hfill
	\begin{minipage}{.4\textwidth}
		Senza GUI
		
		\begin{tabular}{|l|l|l|}
			\hline
			\multicolumn{1}{|c|}{\textbf{N. corpi}} & \multicolumn{1}{c|}{\textbf{N. step}} & \multicolumn{1}{c|}{\textbf{Tempo}} \\ \hline
			100 & 1000 & 0,11 \\ \hline
			100 & 10000 & 0,602 \\ \hline
			100 & 50000 & 2,939 \\ \hline
			1000 & 1000 & 1,403 \\ \hline
			1000 & 10000 & 14,139 \\ \hline
			1000 & 50000 & 65,73 \\ \hline
			5000 & 1000 & 47,193 \\ \hline
			5000 & 10000 & 474,334 \\ \hline
			5000 & 50000 & 2351,408 \\ \hline
		\end{tabular}
	\end{minipage}
	\hfill
	\begin{minipage}{.4\textwidth}
		Con GUI
		
		\begin{tabular}{|l|l|l|}
			\hline
			\multicolumn{1}{|c|}{\textbf{N. corpi}} & \multicolumn{1}{c|}{\textbf{N. step}} & \multicolumn{1}{c|}{\textbf{Tempo}} \\ \hline
			100 & 1000 & 0,117 \\ \hline
			100 & 10000 & 0,74 \\ \hline
			100 & 50000 & 3,364 \\ \hline
			1000 & 1000 & 3,101 \\ \hline
			1000 & 10000 & 30,25 \\ \hline
			1000 & 50000 & 143,894 \\ \hline
			5000 & 1000 & 68,841 \\ \hline
			5000 & 10000 & 673,219 \\ \hline
			5000 & 50000 & 3328,55 \\ \hline
		\end{tabular}
	\end{minipage}
	\hfill

	\subsubsection{Speedup}
	Valori speedup (misurati con 1000 corpi e 10000 step).
	
	\hfill
	\begin{minipage}{.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{speedup-no-gui}
		\label{fig:speedup-no-gui}
	\end{minipage}
	\hfill
	\begin{minipage}{.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{speedup-gui}
		\label{fig:speedup-gui}
	\end{minipage}
	\hfill
	
	\subsubsection{Strong scaling efficiency}
	\hfill
	\begin{minipage}{.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{sse-no-gui}
		\label{fig:sse-no-gui}
	\end{minipage}
	\hfill
	\begin{minipage}{.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{sse-gui}
		\label{fig:sse-gui}
	\end{minipage}
	\hfill
\end{document}